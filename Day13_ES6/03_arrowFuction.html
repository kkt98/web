<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>두꺼운 화살표 함수</title>
</head>
<body>
    
    <script>

        //화살표 함수 - 자바, kotlin 언어의 람다 표기법

        //1. 선언적 함수 [가장 일반적인 함수]
        function show(){
            document.write("show!!<br>")
        }
        show()//함수호출

        //2. 함수를 변수에 저장하여 사용하기('익명함수'라고 부름)
        let output =  function(){
            document.write("output<br>")
        }
        //함수를 가진 변수명이 함수이름으로 활용됨
        output()

        //3. 위 '익명함수'를 줄여쓰고 싶을때 [두꺼운 화살표 함수]
        let display = () => {
            document.write("display<br>")
        }
        display()

        //화살표함수도 파라미터를 받을 수 있음.
        let display2 = (name) => {
            document.write(name + "<br>")
        }
        display2("sam")

        //화살표 함수의 파라미터가 1개라면 ()를 생략할 수 있음
        let display3 = name => {
            document.write("display3 : " + name + "<br>")
        }
        display3("robin")

        //만약 =>{} 안의 실행문이 한줄이라면 {}조차도 생략할 수 있음
        let display4 = name => document.write("display4 : " + name + "<br>")
        display4("kim")

        //만약 파라미터가 1개도 없다면 ()생략 불가능
        let display5 = () => document.write("displat5<br>")
        display5()

        //만약 파라미터가 2개 이상이면 ()생략 불가능
        let display6 = (name, age) => document.write(name + ":" + age + "<br>")
        display6("hong", 25)

    </script>

    <hr>

    <!-- 보통 화살표함수는 '이벤트처리' 콜백함수용으로 많이 활용됨 -->
    <button id="btn">button</button>
    <h4 id="hh">Hello</h4>

    <script>

        //버튼 클릭이벤트 처리하기
        //1) 기존방식
        var btn = document.getElementById('btn')
        btn.onclick = function(){
            document.getElementById('hh').innerHTML = "Nice"
        }

        //2)화살표함수로 이벤트 처리
        btn.onclick = () => document.getElementById('hh').innerHTML = "Click Button"

    </script>

    <hr>

    <h3 id="hhh"></h3>

    <script>

        const hhh = document.getElementById('hhh')

        //배열의 요소에 접근하는 방법에서도 화살표함수는 많이 활용됨
        let arr = [10, 20, 30]
        hhh.innerHTML += arr[0]
        hhh.innerHTML += arr[1]
        hhh.innerHTML += arr[2]

        hhh.innerHTML = ""
        for(let i=0; i<arr.length; i++){
            hhh.innerHTML += arr[i] + "<br>"
        }
        hhh.innerHTML += "<hr>"

        //위 반복문은 비교연산자들을 사용하다보니 실수의 가능성 있음.
        //인덱스 번호를 조금 쉽게 얻어오는 연산자 in
        for(index in arr){ // 0, 1, 2
            hhh.innerHTML += arr[index] + "<br>"
        }
        hhh.innerHTML += "<hr>"

        //위의 in도 짜증 인덱스 번호를 얻어오면 사용할때 조금 불편함
        //그래서 ES5 버전에서 등장한 배열객체의 forEach(), map() 메소드
        //forEach()메소드의 파라미터로 전달한 함수가 배열의 요소개수만큼 반복적으로 호출됨
        arr.forEach( function(value, index, array){
            hhh.innerHTML += value + "<br>"
        } )
        hhh.innerHTML += "<hr>"

        //forEach()의 파라미터로 전달된 익명함수를 '화살표함수'로 바꿔보기
        arr.forEach( value =>  hhh.innerHTML += value + "<br>")
        hhh.innerHTML += "<hr>"

        // .map() : forEach()와 똑같이 반복호출됨 ..return이 있음.
        let aaa = arr.map(function(value, index){
            return value+1
        })
        hhh.innerHTML = aaa //배열을 출력하면 자동 요소,요소,요소

        //위 동작을 화살표함수로
        //화살표함수에서 {}를생략할때는 return키워드도 생략해야함
        let bbb = arr.map(value => value+2)
        hhh.innerHTML = bbb

    </script>

</body>
</html>